grammar cz.cvut.earlgrey.sequencemodel.Sequencemodel with cz.cvut.earlgrey.annotation.Annotation

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate sequencemodel "http://www.cvut.cz/earlgrey/sequencemodel/Sequencemodel"

Model:
    (imports+=Import)* (sequence+=Sequence)*;

Import:
    'import' importURI=STRING;
    

Sequence:
    annotation+=Annotation* =>
    'sequence' name=ID
        (=> participant+=Participant (=> ',' participant+=Participant)*)?
        transition+=Transition*
    'end'
;

// e.g.: Node
Participant:
    name=ID
;

Transition:
    Message | Fragment
;

//// e.g.: def append(child : Node) end
//TransitionBlock:
//    'def' name=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')? //':'
//        transition+=Transition*
//    'end'
//;

Fragment:
    IfElseFragment
    | ForeachFragment
    | AssertFragment
    | LoopFragment
    | BreakFragment
    | NextFragment
;

IfElseFragment: //alt/opt
    'if' expr=ValueWithSpaces 'then'
        transition+=Transition*
     (=> 'elsif' elseIfExpr+=ValueWithSpaces 'then'
         elseIftransition+=Transition*
     )*
     (=> 'else'
        elseTransition+=Transition*
     )? 
    'end'
;

// e.g.: foreach node in Nodes do /*..*/ end
// e.g.: foreach i in 0..5 do /*..*/ end
ForeachFragment:
    'foreach' expr=ForeachExpression 'do'
        transition+=Transition*
    'end'
;

// e.g.: while i < 0 do /*..*/ end
LoopFragment: //loop
    'while' expr=ValueWithSpaces 'do'
        transition+=Transition*
    'end'
;

AssertFragment: //assert
    'assert' expr=ValueWithSpaces 'then'
        transition+=Transition*
    'end'
;

// use this instead of:
//   if i > 0 then break end
// e.g.: break i > 0 then /*..*/ end
BreakFragment:
    {BreakFragment} 'break' (expr=ValueWithSpaces 'then'
        transition+=Transition*
    'end')?
;

// use this instead of:
//   if i > 0 then continue end
// e.g.: next i % 5 then /*..*/ end
NextFragment:
    {NextFragment} 'next' (expr=ValueWithSpaces 'then'
        transition+=Transition*
    'end')?
;

//
Message:
    CallMessage
    | NewMessage
//    | ReturnMessage
    | DeleteMessage
    | SelfMessage
    | FoundMessage
;

FoundMessage:
    'calls' (targetParticipant=ID '.')? => name=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')? 
    return=ReturnMessage?
;

// e.g.: Handler calls Node.getChild()
CallMessage:
    sourceParticipant=ID 'calls' (targetParticipant=ID '.')? => name=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')? 
    return=ReturnMessage?
;

// e.g.: new Node
// TODO: implicitValues? "new Node(null, 5, 8)" -- child, x, y
NewMessage:
    sourceParticipant=ID 'creates' targetParticipant=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')?
;

// e.g.: return childs
ReturnMessage:
    'returns' name=Reference (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')?
;

DeleteMessage:
    sourceParticipant=ID 'destroys' targetParticipant=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')?
;

//TODO: rewrite this rule, do we really need begin-end?
SelfMessage:
    sourceParticipant=ID 'self' '.' name=ID (=> '(' (=> parameter+=Parameter (',' parameter+=Parameter)*)? ')')? return=ReturnMessage?
    (=>  'begin'
        transition+=Transition*
    'end')?
;

// e.g.: Name : String = "John"
Parameter:
    name=ID (':' type=Reference)?
;

Reference:
    type=ID array+=Array*
;

Array:
    {Array} '[' size=NATURAL? ']'
;

ForeachExpression hidden(WS):
    ID 'in' ((NATURAL '..' NATURAL) | ID)
;

//ValueWithSpacesExpr hidden():
//    (OPERATOR | (NATURAL '..' NATURAL) | Value | ANY_OTHER | WS)*
//;

ValueWithSpaces hidden():
    (OPERATOR | Value | ANY_OTHER | WS)*
;
