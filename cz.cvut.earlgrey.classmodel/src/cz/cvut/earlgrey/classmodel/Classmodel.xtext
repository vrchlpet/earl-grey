grammar cz.cvut.earlgrey.classmodel.Classmodel with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate classmodel "http://www.cvut.cz/earlgrey/classmodel/Classmodel"

/**
 * Defines root node of a model.
 * Resource imports must be defined before other elements.
 */
Classmodel:
    (imports+=Import)* (elements+=AbstractElement)*;

AbstractElement:
    Package | Entity | Relation;

Package:
    'package' name=ID '{'
    (elements+=AbstractElement)*
    '}';

Import:
    'import' importURI=STRING;

Entity:
    Class | Enum;
    
Class returns Entity:
    => (class?='class'| interface?='interface'| abstract?='abstract') name=ID
    '{'
    feature+=Feature*
    '}'
;

Enum returns Entity:
    enumeration?='enum' name=ID
    '{'
    feature+=EnumConstant*
    '}';

EnumConstant returns Attribute:
    name=ID (=> '=' implicit+=IntValue)?
;

/**
 * Entity reference, supports n-dimension arrays.
 */
Reference:
    type=[Entity|QualifiedName] array+=Array*;

Array:
    {Array} '[' size=INT? ']';

Feature:
    Attribute | Operation;

//i.e.: +setAll(Parameter[]) : void
Operation:
    (modifier=Visibility? & static?='static'?) name=ID '(' (=> parameters+=Parameter (',' parameters+=Parameter)*)? ')'
    ':'
    return=Reference;

Parameter:
    name=ID ':' type=Reference (=> '=' implicit+=Value (',' implicit+=Value)*)?;

Attribute:
    (modifier=Visibility? & static?='static'?) name=ID ':' type=Reference (=> '=' implicit+=Value (',' implicit+=Value)*)?;

Value returns ecore::EString:
   'null' | STRING | IntValue
;

IntValue returns ecore::EString:
    INT
;

Relation:
    origin=[Entity|QualifiedName] (cardinalityFrom=Cardinality)? type=RelationType (cardinalityTo=Cardinality)?
    destination=[Entity|QualifiedName] (':' label=STRING)?;
    
Cardinality returns ecore::EString:
    CardinalityValue ('..' CardinalityValue)?
;

CardinalityValue returns ecore::EString:
    INT | '*'
;

/**
 * Relation type:
 * A is in relationship with B
 * 
 * i.e.: A extends B
 */
enum RelationType:
    ASSOCIATION='associates' //A is in assocition with B 
    | DEPENCY='depends' //A depends on B
    | GENERALIZATION='extends' //A extends B
    | REALIZATION='implements' //A implements B
    | AGGREGATION='aggregates' //A aggregates B (A consists of B(s), but A can exist without B)
    | COMPOSITION='composedOf' //A x B (A is composed of B(s), but can't exist without B)
;

enum Visibility:
    PUBLIC='+' | PRIVATE='-' | PROTECTED='#' | PACKAGE_PRIVATE='~';

enum EntityType:
    CLASS='class' | INTERFACE='interface' | ABSTRACT='abstract' | ENUM='enum'
    ;

QualifiedName:
    ID ('.' ID)*;

//TODO: Add constrain rule

//terminal CONSTRAIN:
//    '{'->'}';
    