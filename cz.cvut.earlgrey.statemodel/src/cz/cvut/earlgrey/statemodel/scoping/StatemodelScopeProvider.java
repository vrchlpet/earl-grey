/*
 * generated by Xtext
 */
package cz.cvut.earlgrey.statemodel.scoping;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import cz.cvut.earlgrey.statemodel.statemodel.Statemachine;
import cz.cvut.earlgrey.statemodel.statemodel.Transition;

/**
 * This class contains custom scoping description.
 * 
 * TODO: add scope for a method
 */
public class StatemodelScopeProvider extends AbstractDeclarativeScopeProvider {

	/**
	 * Tries to get states from a Statemachine, which containts this Transition.
	 * 
	 * @param call Transition object contains States
	 * @param ref EReference
	 * @return IScope
	 */
	IScope scope_Transition_state(Transition call, EReference ref) {
		Statemachine machine = (Statemachine) getParent(call.eContainer());
		if (machine != null) {
			return Scopes.scopeFor(machine.getState());
		}
		return super.getScope(call, ref);
	}

	// public IScope scope_Transition_method(Transition call, EReference ref) {
	// System.out.println("jhgjghjg");
	// return IScope.NULLSCOPE;
	// }

	// @Override
	// public IScope getScope(EObject context, EReference reference) {
	// // System.out.println("con >>> " + context + " \nref >>>" + reference);
	// String methodName = "scope_"
	// + reference.getEContainingClass().getName() + "_"
	// + reference.getName();
	// System.out.println(methodName);
	//
	// IScope scope = polymorphicFindScopeForReferenceName(context,
	// reference);
	// if (scope == null) {
	// System.out.println("polymorphicFindScopeForReferenceName null");
	// scope = polymorphicFindScopeForClassName(context, reference);
	// if (scope == null) {
	// System.out.println("polymorphicFindScopeForClassName null");
	// scope = delegateGetScope(context, reference);
	// }
	// }
	// return super.getScope(context, reference);
	// }

	// public IScope scope_Event_ref(Event call, EReference ref) {
	// EObject parent = call.eContainer().eContainer().eContainer();
	// System.out.println(parent.eClass().toString());
	// return IScope.NULLSCOPE;
	// }

	// IScope scope_State_transition(State call, EReference ref) {
	// System.out.println("being called");
	// Statemachine machine = (Statemachine) call.eContainer();
	//
	// if (machine != null) {
	// IScope b = Scopes.scopeFor(machine.getReference().getMethod());
	// Iterable<IEObjectDescription> c = b.getAllElements();
	// for (IEObjectDescription ieObjectDescription : c) {
	// System.out.println(ieObjectDescription);
	// }
	// return Scopes.scopeFor(machine.getReference().getMethod());
	// }
	// return IScope.NULLSCOPE;
	// // return super.getScope(call, ref);
	// }

	/**
	 * Get a parent EObject of a EObject.
	 * 
	 * @param obj EObject.
	 * @return null or EObject
	 */
	private EObject getParent(EObject obj) {
		return (obj != null ? obj.eContainer() : null);
	}

	// private EObject findParent(EObject obj, Class<?> c) {
	// System.out.println(obj + " " + c);
	// if (c.isInstance(obj)) {
	// System.out.println(obj + " is true");
	// }
	// return null;
	// }
}
